# 提交消息约定

## 提交消息格式

每个提交消息都由**头部**、**正文**和**脚注**组成。头部有一种特殊的格式，包含**类型**、可选的**范围**和**主题**：

```
<类型>(<可选范围>): <主题>
<空行>
<正文>
<空行>
<脚注>
```

**头部**是必需的，而**范围**是可选的。

提交消息的任何一行都不能超过100个字符！这可以使消息在GitHub以及各种Git工具中更容易阅读。

脚注应该包含对提交的相关问题的引用，例如：

```
修复 #123
关闭 #123
```

或者在破坏性变更的情况下：

```
不兼容变更: <不兼容变更的描述>
```

### 类型

必须是下列之一：

* **feat**: 新功能
* **fix**: Bug修复
* **docs**: 仅文档变更
* **style**: 不影响代码含义的变更（空白、格式化、缺少分号等）
* **refactor**: 既不修复bug也不添加功能的代码变更
* **perf**: 改进性能的代码变更
* **test**: 添加缺失测试或修正现有测试
* **chore**: 对构建过程或辅助工具和库的变更，例如文档生成

### 范围

范围可以是任何指定提交变更位置的内容，例如子包名称、组件名称等。

例如 `core`, `common`, `api`, `cli` 等。

### 主题

主题是对变更的简洁描述：

* 使用祈使句，现在时："改变"而不是"已改变"或"改变了"
* 不要把首字母大写
* 不在末尾加句号（.）

### 正文

正文应该包括更改的动机，并将其与以前的行为进行对比。使用祈使句，现在时。

### 脚注

脚注可以包含以下两类信息：

#### 破坏性变更

所有破坏性变更必须在脚注中以"不兼容变更: "开头，后跟变更描述、变更的理由以及迁移说明。

```
不兼容变更: 发送短信API现在使用新的认证方式

- 新的授权使用JWT而不是API密钥
- 迁移指南:
  - 生成JWT令牌
  - 使用新的Authorization标头发送请求
```

#### 引用问题

关闭的问题应在脚注中以"关闭"关键字为前缀列出，如下所示：

```
关闭 #234
```

## 提交消息示例

### 包含范围的功能

```
feat(认证): 添加JWT认证支持

实现了JWT认证机制，包括：
- 令牌生成
- 令牌验证
- 错误处理

关闭 #123
```

### 包含破坏性变更的修复

```
fix(认证): 更新认证流程

替换了旧的基于密钥的认证系统，提高安全性。

不兼容变更: 认证方法签名已更改

- 旧方法: Authenticate(key string)
- 新方法: Authenticate(ctx context.Context, req AuthRequest)

迁移应更新所有调用以使用新的参数结构。
参见迁移文档获取详细步骤: docs/migrations/auth-v2.md

关闭 #431
```

### 不带正文的简单提交

```
docs: 更新README中的使用示例
```

### 带有范围和问题引用的提交

```
style(日志): 规范日志格式和级别

关闭 #1110
```

## 使用工具生成规范提交

您可以使用以下工具来帮助生成符合约定的提交消息：

1. [commitizen](https://github.com/commitizen/cz-cli)
2. [commitlint](https://github.com/conventional-changelog/commitlint)

## 基于提交的发布

此项目使用[semantic-release](https://github.com/semantic-release/semantic-release)自动化版本管理和发布过程。它根据提交消息确定下一个版本号，生成发布说明，并发布包。

### 版本策略

* `fix` 类型的提交对应补丁版本 (0.0.x)
* `feat` 类型的提交对应次要版本 (0.x.0)
* 带有 `不兼容变更` 注释的提交对应主要版本 (x.0.0)

## 生成变更日志

变更日志是基于提交消息自动生成的，这就是为什么遵循这些约定如此重要的原因。
